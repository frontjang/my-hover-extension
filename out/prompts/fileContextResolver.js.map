{"version":3,"file":"fileContextResolver.js","sourceRoot":"","sources":["../../src/prompts/fileContextResolver.ts"],"names":[],"mappings":"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","sourcesContent":["import { Dirent } from 'fs';\nimport * as fsPromises from 'fs/promises';\nimport * as path from 'path';\n\ninterface StemMatch {\n  path: string;\n  score: number;\n}\n\nexport interface FileContextResolverOptions {\n  /**\n   * Absolute directories that should be searched when resolving references.\n   */\n  readonly roots: readonly string[];\n  /**\n   * Maximum number of files that will be visited when searching by filename only.\n   */\n  readonly maxSearchEntries?: number;\n}\n\nexport interface FileContextResult {\n  readonly absolutePath: string;\n  readonly displayPath: string;\n  readonly line: number;\n  readonly snippet: string;\n}\n\nconst STEM_EXTENSION_PRIORITY = [\n  '.py',\n  '.ts',\n  '.tsx',\n  '.js',\n  '.jsx',\n  '.c',\n  '.cc',\n  '.cpp',\n  '.h',\n  '.hpp',\n  '.java',\n  '.cs',\n  '.go',\n  '.rs',\n  '.php',\n  '.rb',\n  '.kt',\n  '.swift',\n  '.m',\n  '.mm',\n  '.json',\n  '.yaml',\n  '.yml',\n  '.md',\n  '.txt'\n];\n\nexport class FileContextResolver {\n  private readonly roots: string[];\n  private readonly maxSearchEntries: number;\n\n  constructor(options: FileContextResolverOptions) {\n    this.roots = options.roots.map((root) => path.resolve(root));\n    this.maxSearchEntries = options.maxSearchEntries ?? 2000;\n  }\n\n  async resolve(referencePath: string, line: number): Promise<FileContextResult | undefined> {\n    if (!referencePath) {\n      return undefined;\n    }\n\n    const normalizedReference = referencePath.replace(/\\\\/g, '/');\n    const candidate = await this.findFile(normalizedReference);\n\n    if (!candidate) {\n      console.log(\n        `[MyHoverExtension] Unable to resolve reference path \"${referencePath}\" using roots ${\n          this.roots.length > 0 ? this.roots.join(', ') : '<none>'\n        }.`\n      );\n      return undefined;\n    }\n\n    try {\n      const contents = await fsPromises.readFile(candidate, 'utf8');\n      const lines = contents.split(/\\r?\\n/);\n      const zeroBasedLine = Math.max(0, line - 1);\n\n      if (zeroBasedLine >= lines.length) {\n        console.log(\n          `[MyHoverExtension] Resolved file \"${candidate}\" does not contain line ${line}.`\n        );\n        return undefined;\n      }\n\n      const snippet = extractFunctionBlock(lines, zeroBasedLine, candidate);\n      const displayPath = this.makeDisplayPath(candidate);\n\n      return {\n        absolutePath: candidate,\n        displayPath,\n        line,\n        snippet\n      };\n    } catch (error) {\n      console.error('[MyHoverExtension] Failed to read referenced file:', error);\n      return undefined;\n    }\n  }\n\n  private makeDisplayPath(resolvedPath: string): string {\n    for (const root of this.roots) {\n      if (resolvedPath.startsWith(root)) {\n        return path.relative(root, resolvedPath) || path.basename(resolvedPath);\n      }\n    }\n\n    return resolvedPath;\n  }\n\n  private async findFile(referencePath: string): Promise<string | undefined> {\n    if (path.isAbsolute(referencePath)) {\n      if (await this.exists(referencePath)) {\n        return referencePath;\n      }\n\n      return undefined;\n    }\n\n    for (const root of this.roots) {\n      const joined = path.join(root, referencePath);\n\n      if (await this.exists(joined)) {\n        return joined;\n      }\n    }\n\n    const filename = path.basename(referencePath);\n\n    if (!filename) {\n      return undefined;\n    }\n\n    let visited = 0;\n\n    for (const root of this.roots) {\n      const result = await this.walkForFile(root, filename, () => {\n        visited += 1;\n        return visited > this.maxSearchEntries;\n      });\n\n      if (result) {\n        return result;\n      }\n    }\n\n    const stem = path.parse(filename).name;\n\n    if (!stem) {\n      return undefined;\n    }\n\n    visited = 0;\n    let bestMatch: StemMatch | undefined;\n\n    for (const root of this.roots) {\n      const match = await this.walkForFileByStem(root, stem, () => {\n        visited += 1;\n        return visited > this.maxSearchEntries;\n      });\n\n      if (match && (!bestMatch || match.score < bestMatch.score)) {\n        bestMatch = match;\n      }\n\n      if (visited > this.maxSearchEntries) {\n        break;\n      }\n    }\n\n    if (bestMatch) {\n      console.log(\n        `[MyHoverExtension] Resolved reference \"${referencePath}\" using filename stem match -> \"${bestMatch.path}\".`\n      );\n      return bestMatch.path;\n    }\n\n    return undefined;\n  }\n\n  private scoreExtension(ext: string): number {\n    const normalized = ext.toLowerCase();\n    const index = STEM_EXTENSION_PRIORITY.indexOf(normalized);\n\n    if (index >= 0) {\n      return index;\n    }\n\n    return STEM_EXTENSION_PRIORITY.length + (normalized ? 1 : 0);\n  }\n\n  private async walkForFileByStem(\n    directory: string,\n    stem: string,\n    shouldStop: () => boolean\n  ): Promise<StemMatch | undefined> {\n    if (shouldStop()) {\n      return undefined;\n    }\n\n    let entries: Dirent[];\n\n    try {\n      entries = await fsPromises.readdir(directory, { withFileTypes: true });\n    } catch {\n      return undefined;\n    }\n\n    let bestMatch: StemMatch | undefined;\n\n    for (const entry of entries) {\n      const fullPath = path.join(directory, entry.name);\n\n      if (entry.isDirectory()) {\n        const nested = await this.walkForFileByStem(fullPath, stem, shouldStop);\n\n        if (nested && (!bestMatch || nested.score < bestMatch.score)) {\n          bestMatch = nested;\n        }\n      } else if (entry.isFile()) {\n        const entryStem = path.parse(entry.name).name;\n\n        if (entryStem === stem) {\n          const score = this.scoreExtension(path.extname(entry.name));\n          const candidate: StemMatch = { path: fullPath, score };\n\n          if (!bestMatch || candidate.score < bestMatch.score) {\n            bestMatch = candidate;\n          }\n        }\n      }\n\n      if (shouldStop()) {\n        break;\n      }\n    }\n\n    return bestMatch;\n  }\n\n  private async walkForFile(\n    directory: string,\n    filename: string,\n    shouldStop: () => boolean\n  ): Promise<string | undefined> {\n    if (shouldStop()) {\n      return undefined;\n    }\n\n    let entries: Dirent[];\n\n    try {\n      entries = await fsPromises.readdir(directory, { withFileTypes: true });\n    } catch (error) {\n      return undefined;\n    }\n\n    for (const entry of entries) {\n      const fullPath = path.join(directory, entry.name);\n\n      if (entry.isDirectory()) {\n        const found = await this.walkForFile(fullPath, filename, shouldStop);\n\n        if (found) {\n          return found;\n        }\n      } else if (entry.isFile() && entry.name === filename) {\n        return fullPath;\n      }\n\n      if (shouldStop()) {\n        return undefined;\n      }\n    }\n\n    return undefined;\n  }\n\n  private async exists(filePath: string): Promise<boolean> {\n    try {\n      await fsPromises.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n\nconst FUNCTION_HEADER_PATTERNS: RegExp[] = [\n  /^\\s*(export\\s+)?(async\\s+)?function\\s+\\w+/,\n  /^\\s*(export\\s+)?(async\\s+)?(const|let|var)\\s+\\w+\\s*=\\s*(async\\s*)?\\(/,\n  /^\\s*(export\\s+)?(const|let|var)\\s+\\w+\\s*=\\s*(async\\s*)?function\\b/,\n  /^\\s*(export\\s+)?class\\s+\\w+/,\n  /^\\s*def\\s+\\w+\\s*\\(.*\\)\\s*:/\n];\n\nfunction extractFunctionBlock(lines: string[], targetLine: number, filePath: string): string {\n  const headerIndex = findHeaderLine(lines, targetLine);\n  const docStart = includeLeadingDocstring(lines, headerIndex);\n  const ext = path.extname(filePath).toLowerCase();\n\n  if (ext === '.py') {\n    const end = findPythonBlockEnd(lines, headerIndex);\n    return lines.slice(docStart, end + 1).join('\\n');\n  }\n\n  const end = findBraceLanguageBlockEnd(lines, headerIndex);\n  return lines.slice(docStart, end + 1).join('\\n');\n}\n\nfunction findHeaderLine(lines: string[], start: number): number {\n  for (let index = start; index >= 0; index -= 1) {\n    const text = lines[index];\n\n    if (!text.trim()) {\n      continue;\n    }\n\n    if (FUNCTION_HEADER_PATTERNS.some((pattern) => pattern.test(text))) {\n      return index;\n    }\n  }\n\n  return start;\n}\n\nfunction includeLeadingDocstring(lines: string[], headerIndex: number): number {\n  let index = headerIndex - 1;\n  let docStart = headerIndex;\n\n  while (index >= 0) {\n    const text = lines[index];\n\n    if (!text.trim()) {\n      index -= 1;\n      continue;\n    }\n\n    if (/^\\s*(\\/\\/|#)/.test(text) || /^\\s*\\*/.test(text) || /\"\"\"|'''/.test(text)) {\n      docStart = index;\n      index -= 1;\n      continue;\n    }\n\n    if (/^\\s*\\/\\*/.test(text)) {\n      docStart = index;\n      index -= 1;\n      continue;\n    }\n\n    break;\n  }\n\n  return docStart;\n}\n\nfunction findBraceLanguageBlockEnd(lines: string[], headerIndex: number): number {\n  let depth = 0;\n  let end = headerIndex;\n  let sawOpeningBrace = false;\n\n  for (let index = headerIndex; index < lines.length; index += 1) {\n    const text = lines[index];\n\n    for (const char of text) {\n      if (char === '{') {\n        depth += 1;\n        sawOpeningBrace = true;\n      } else if (char === '}') {\n        depth -= 1;\n\n        if (sawOpeningBrace && depth <= 0) {\n          return index;\n        }\n      }\n    }\n\n    end = index;\n  }\n\n  return end;\n}\n\nfunction findPythonBlockEnd(lines: string[], headerIndex: number): number {\n  const header = lines[headerIndex];\n  const indentMatch = /^\\s*/.exec(header) ?? [''];\n  const headerIndent = indentMatch[0].length;\n  let end = headerIndex;\n  let inDocstring = false;\n  let docstringDelimiter: string | undefined;\n\n  for (let index = headerIndex + 1; index < lines.length; index += 1) {\n    const text = lines[index];\n    const trimmed = text.trim();\n\n    if (!trimmed) {\n      end = index;\n      continue;\n    }\n\n    if (!inDocstring && (trimmed.startsWith('\"\"\"') || trimmed.startsWith(\"'''\"))) {\n      inDocstring = true;\n      docstringDelimiter = trimmed.startsWith('\"\"\"') ? '\"\"\"' : \"'''\";\n      end = index;\n      if (trimmed.endsWith(docstringDelimiter) && trimmed.length > docstringDelimiter.length) {\n        inDocstring = false;\n      }\n      continue;\n    }\n\n    if (inDocstring) {\n      end = index;\n      if (trimmed.endsWith(docstringDelimiter ?? '')) {\n        inDocstring = false;\n      }\n      continue;\n    }\n\n    const indentLength = ( /^\\s*/.exec(text) ?? [''])[0].length;\n\n    if (indentLength <= headerIndent && /^[^#]/.test(trimmed)) {\n      break;\n    }\n\n    end = index;\n  }\n\n  return end;\n}\n"]}